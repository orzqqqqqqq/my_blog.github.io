<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2021华为软件比赛" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/2021%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%AF%94%E8%B5%9B/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:46.668Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;cstring&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;cstdlib&quot;</span><br><span class="line">#include &quot;cstdio&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;list&quot;</span><br><span class="line">#include &quot;unordered_map&quot;</span><br><span class="line">#include &quot;cmath&quot;</span><br><span class="line">#include &quot;assert.h&quot;</span><br><span class="line">#include &quot;ctime&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">const int MXQ = 2e5 + 3;</span><br><span class="line">const int MXV = 2003;</span><br><span class="line">const int MXS = 203;</span><br><span class="line">const int MAX_T = 1e3 + 7;</span><br><span class="line">const int MAX_num = 10;</span><br><span class="line">const int inf = 1e9;</span><br><span class="line"></span><br><span class="line">const double W_remt = 1.0;</span><br><span class="line">const double W_ratio = 1.2;</span><br><span class="line">const double W_x = 2;</span><br><span class="line">//不要太大</span><br><span class="line">const double W_p = 0.0001;</span><br><span class="line">#define debug(...) cout &lt;&lt; &quot;[&quot; &lt;&lt; #__VA_ARGS__ &lt;&lt; &quot;]: &quot;, debug_out(__VA_ARGS__);</span><br><span class="line">void debug_out() &#123; cout &lt;&lt; &#x27;\n&#x27;; &#125;</span><br><span class="line">template &lt;typename T, typename... R&gt;</span><br><span class="line">void debug_out(const T&amp; f, const R &amp;... r) &#123;</span><br><span class="line">    cout &lt;&lt; f &lt;&lt; &quot; &quot;;</span><br><span class="line">    debug_out(r...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Server &#123;</span><br><span class="line">    int cpu[2], mem[2];</span><br><span class="line">    int cost, day_cost;</span><br><span class="line">    Server() &#123;&#125;</span><br><span class="line">    Server(int c, int m, int cost, int day_cost) : cost(cost), day_cost(day_cost) &#123;</span><br><span class="line">        cpu[0] = cpu[1] = c / 2;</span><br><span class="line">        mem[0] = mem[1] = m / 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;ser[MXS];</span><br><span class="line">vector&lt;Server&gt; has_buy_s;</span><br><span class="line">list&lt;int&gt; last_buy_s[MXQ];</span><br><span class="line">char ser_name[MXS][24];</span><br><span class="line">int s2v_num[MXS][MXV], total_s2v[MXS], cnt_v[MXV], T_cnt[MXV][MXV], T_sub_cnt[MXV][MXV];</span><br><span class="line">long long Total_cost;</span><br><span class="line"></span><br><span class="line">struct VirtualSever &#123;</span><br><span class="line">    int cpu, mem;</span><br><span class="line">    int bi;</span><br><span class="line">    VirtualSever() &#123;&#125;</span><br><span class="line">    VirtualSever(int cpu, int mem, int bi) : cpu(cpu), mem(mem), bi(bi) &#123;&#125;</span><br><span class="line">&#125;v_s[MXV];</span><br><span class="line"></span><br><span class="line">struct ptrCmp &#123;</span><br><span class="line">    bool operator()(const char* lhs, const char* rhs) const &#123;</span><br><span class="line">        return strcmp(lhs, rhs) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, int&gt; v_server;</span><br><span class="line">map&lt;int, string&gt; q_vs;</span><br><span class="line"></span><br><span class="line">struct Query &#123;</span><br><span class="line">    int qid, vid, tid;</span><br><span class="line">    Query(int q, int v, int tid) : qid(q), vid(v), tid(tid) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct V2S &#123;</span><br><span class="line">    int s_id;</span><br><span class="line">    double cost;</span><br><span class="line">    V2S(int s_id, double cost) :s_id(s_id), cost(cost) &#123;&#125;</span><br><span class="line">    bool operator &lt; (const V2S&amp; rhs) const &#123;</span><br><span class="line">        return cost &lt; rhs.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;V2S&gt;v2s[MXV];</span><br><span class="line">double total_cost_s[MXS], cost_s[MXS][MXV];</span><br><span class="line">int v_mins[MXV][MAX_num];</span><br><span class="line">//虚拟机的排序方式，公式定义</span><br><span class="line">bool cmp_query(const Query&amp; a, const Query&amp; b) &#123;</span><br><span class="line">    int va_id = a.vid;</span><br><span class="line">    int vb_id = b.vid;</span><br><span class="line">    double pa = 1.0 * v_s[va_id].cpu / v_s[va_id].mem;</span><br><span class="line">    double pb = 1.0 * v_s[vb_id].cpu / v_s[vb_id].mem;</span><br><span class="line">    if(v_s[va_id].bi != v_s[vb_id].bi)</span><br><span class="line">        return v_s[va_id].bi &lt; v_s[vb_id].bi;</span><br><span class="line">    if(fabs(pa-pb) &gt; 0.01)</span><br><span class="line">        return pa &lt; pb;</span><br><span class="line">    return cnt_v[va_id] &gt; cnt_v[vb_id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Arrange &#123;</span><br><span class="line">    int s_id, s_n_id, tim;</span><br><span class="line">    Arrange() &#123;&#125;</span><br><span class="line">    Arrange(int s_id, int s_n_id, int tim) : s_id(s_id), s_n_id(s_n_id), tim(tim) &#123;&#125;</span><br><span class="line">&#125;s_arrange[MXQ], cur_arrange[MXQ];</span><br><span class="line"></span><br><span class="line">struct Qratio&#123;</span><br><span class="line">    int qid, v_id, s_id;</span><br><span class="line">    double cost;</span><br><span class="line">    Qratio()&#123;&#125;</span><br><span class="line">    Qratio(int qid, int v_id, int s_id, double cost):qid(qid), v_id(v_id), s_id(s_id), cost(cost)&#123;&#125;</span><br><span class="line">    bool operator &lt; (const Qratio &amp; rhs) const&#123;</span><br><span class="line">//        if(fabs(cost-rhs.cost) &lt; 1)</span><br><span class="line">//            return s_id &gt; rhs.s_id;</span><br><span class="line">//        return cost &gt; rhs.cost;</span><br><span class="line">        return cur_arrange[qid].s_id &gt; cur_arrange[rhs.qid].s_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q_ratio[MXQ];</span><br><span class="line"></span><br><span class="line">// 对于询问安排的结构体</span><br><span class="line">unordered_map&lt;int, int&gt; qid;</span><br><span class="line">vector&lt;int&gt; ans_buy;</span><br><span class="line">// 预处理 结构体 虚拟机 对 server的映射数组， 需要购买的按公式排序</span><br><span class="line">// 预处理 接上面的结构体, 注意区分bi, v_s与ser都/2了</span><br><span class="line">//int q_ed[MXQ];</span><br><span class="line">void preparation_num(int T)&#123;</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= M; j++) &#123;</span><br><span class="line">            if (ser[i].cpu[0] &gt;= v_s[j].cpu &amp;&amp; ser[i].mem[0] &gt;= v_s[j].mem) &#123;</span><br><span class="line">                s2v_num[i][j] += cnt_v[j];</span><br><span class="line">                total_s2v[i] += cnt_v[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//    const double nnn = 3.6;</span><br><span class="line">//    for(int j = 1; j &lt;= M; j++)&#123;</span><br><span class="line">//        for(int k = 0; k &lt; MAX_num; k++)</span><br><span class="line">//            debug(j,k, v_mins[j][k]);</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void preparation_v2s(int rem_T) &#123;</span><br><span class="line">//    for(int i = 1; i &lt;= N; i++) total_cost_s[i] = 0;</span><br><span class="line">//    for(int j = 1; j &lt;= M; j++) v2s[j].clear();</span><br><span class="line">//    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">//        double cost = (ser[i].cost + ser[i].day_cost * rem_T*W_remt) ;</span><br><span class="line">//        for (int j = 1; j &lt;= M; j++) &#123;</span><br><span class="line">//            if (ser[i].cpu[0] &lt; v_s[j].cpu || ser[i].mem[0] &lt; v_s[j].mem) continue;</span><br><span class="line">//</span><br><span class="line">//            VirtualSever &amp;vs = v_s[j];</span><br><span class="line">//            double num = min(1.0 *ser[i].cpu[0] / vs.cpu, 1.0*ser[i].mem[0]/vs.mem);</span><br><span class="line">//            if(vs.bi == 0) num *= 2;</span><br><span class="line">//            double v_cost = cost / num;</span><br><span class="line">//            v2s[j].push_back(V2S(i, v_cost));</span><br><span class="line">//            cost_s[i][j] = cost;</span><br><span class="line">//            total_cost_s[i] += cost;</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">//    for(int j = 1; j &lt;= M; j++)</span><br><span class="line">//        sort(v2s[j].begin(), v2s[j].end());</span><br><span class="line">    for(int j = 1; j &lt;= M; j++)&#123;</span><br><span class="line">        VirtualSever &amp;vs = v_s[j];</span><br><span class="line">        int min_id = 1;</span><br><span class="line">        double min_cost[MAX_num];</span><br><span class="line">        for(int k = 0; k &lt; MAX_num; k++) min_cost[k] = inf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">            if (ser[i].cpu[0] &lt; v_s[j].cpu || ser[i].mem[0] &lt; v_s[j].mem) continue;</span><br><span class="line"></span><br><span class="line">            double cost = (ser[i].cost + ser[i].day_cost * rem_T) ;</span><br><span class="line">            double num = min(1.0 *ser[i].cpu[0] / vs.cpu,  1.0*ser[i].mem[0]/vs.mem);</span><br><span class="line">            if(vs.bi == 0) num *= 2;</span><br><span class="line">            double v_cost = cost / num;</span><br><span class="line">            int id = i;</span><br><span class="line"></span><br><span class="line">            for(int k = 0; k &lt; MAX_num; k++)&#123;</span><br><span class="line">                if(v_cost &lt; min_cost[k]) &#123;</span><br><span class="line">                    double tmp_v = min_cost[k];</span><br><span class="line">                    min_cost[k] = v_cost;</span><br><span class="line">                    v_cost = tmp_v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    int tmpid = v_mins[j][k];</span><br><span class="line">                    v_mins[j][k] = id;</span><br><span class="line">                    id = tmpid;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int k = 1; k &lt; MAX_num; k++)&#123;</span><br><span class="line">            if(min_cost[k] &gt; W_ratio*min_cost[0])</span><br><span class="line">                v_mins[j][k] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除操作如下</span><br><span class="line">void sub_work(int qid, int v_id, int mul = 1) &#123;</span><br><span class="line">//    debug(v_id);</span><br><span class="line"></span><br><span class="line">    int n_id = cur_arrange[qid].s_n_id, s_id = cur_arrange[qid].s_id;</span><br><span class="line">    //debug(v_s[v_id].cpu,v_s[v_id].mem, n_id, s_id, v_id);</span><br><span class="line">    if (n_id == 1) &#123;</span><br><span class="line">        has_buy_s[s_id].cpu[0] += v_s[v_id].cpu*mul;</span><br><span class="line">        has_buy_s[s_id].mem[0] += v_s[v_id].mem*mul;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n_id == 2) &#123;</span><br><span class="line">        has_buy_s[s_id].cpu[1] += v_s[v_id].cpu*mul;</span><br><span class="line">        has_buy_s[s_id].mem[1] += v_s[v_id].mem*mul;</span><br><span class="line">    &#125;</span><br><span class="line">    if(n_id == 3)&#123;</span><br><span class="line">        has_buy_s[s_id].cpu[0] += v_s[v_id].cpu*mul;</span><br><span class="line">        has_buy_s[s_id].mem[0] += v_s[v_id].mem*mul;</span><br><span class="line">        has_buy_s[s_id].cpu[1] += v_s[v_id].cpu*mul;</span><br><span class="line">        has_buy_s[s_id].mem[1] += v_s[v_id].mem*mul;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void update_s2v(int vid)&#123;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)</span><br><span class="line">        if (ser[i].cpu[0] &gt;= v_s[vid].cpu &amp;&amp; ser[i].mem[0] &gt;= v_s[vid].mem) &#123;</span><br><span class="line">            --s2v_num[i][vid];</span><br><span class="line">            --total_s2v[i];</span><br><span class="line">            total_cost_s[i] -= cost_s[i][vid];</span><br><span class="line">        &#125;</span><br><span class="line">    --cnt_v[vid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_new_ser(int vid, double &amp;q_r)&#123;</span><br><span class="line">//    int siz = v2s[vid].size();</span><br><span class="line">//    int ret_id = v2s[vid].begin()-&gt;s_id;</span><br><span class="line">//    for(int j = 1; j &lt; siz; j++)&#123;</span><br><span class="line">//        if(v2s[vid][j].cost &gt; v2s[vid][0].cost* W_ratio) break;</span><br><span class="line">//        int sid = v2s[vid][j].s_id;</span><br><span class="line">//        //ret_id 改为0反而更优？？？6.4和6.3, W_ratio = 1.75</span><br><span class="line">//        if(total_cost_s[sid]/total_s2v[sid] &lt; total_cost_s[0] /total_s2v[0])&#123;</span><br><span class="line">//            ret_id = sid;</span><br><span class="line">//            int x = rand()%7;</span><br><span class="line">//            if(x == 4) break;</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">//    int c = ser[ret_id].cpu[0], m = ser[ret_id].mem[0];</span><br><span class="line">//    int vc = v_s[vid].cpu, vm = v_s[vid].mem;</span><br><span class="line">//    double ps = 1.0*c/m;</span><br><span class="line">//    double pv = 1.0*vc/vm;</span><br><span class="line">//    double p = ps/pv;</span><br><span class="line">//    if(p &lt; 1) p = 1.0/p-W_p;</span><br><span class="line">//    q_r = p;</span><br><span class="line">//</span><br><span class="line">//    return ret_id;</span><br><span class="line"></span><br><span class="line">    return v_mins[vid][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_near(int tim, const VirtualSever&amp; v, int &amp;s_n_id, int vid, double &amp;q_r, bool flag)&#123;</span><br><span class="line">    int siz = has_buy_s.size();</span><br><span class="line">    int near_id = -1;</span><br><span class="line">    double min_dif = MAX_T;</span><br><span class="line">    //概率小于0的反而更好,比例可以被其他的拉回来。</span><br><span class="line">    bool fc = 0;</span><br><span class="line">    for(int i = 0; i &lt; siz; i++) &#123;</span><br><span class="line">        const Server&amp; s = has_buy_s[i];</span><br><span class="line">        const Server&amp; ori_s = ser[ans_buy[i]];</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            if(s.cpu[0] == ori_s.cpu[0] &amp;&amp; s.cpu[1] == ori_s.cpu[1])</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (v.bi == 1) &#123;</span><br><span class="line">            if(s.cpu[0] &lt; v.cpu || s.cpu[1] &lt; v.cpu || s.mem[0] &lt; v.mem || s.mem[1] &lt; v.mem) continue;</span><br><span class="line"></span><br><span class="line">            s_n_id = 3;</span><br><span class="line">            for(int k = 0; k &lt; MAX_num; k++)&#123;</span><br><span class="line">                if(v_mins[vid][k] == 0) break;</span><br><span class="line">                if(ans_buy[i] == v_mins[vid][k]) &#123;</span><br><span class="line">                    fc = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(fc)&#123;</span><br><span class="line">                near_id = i;</span><br><span class="line">                s_n_id = 3;</span><br><span class="line">                min_dif = -MAX_T;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            bool flag1 = (s.cpu[0] &gt;= v.cpu &amp;&amp; s.mem[0] &gt;= v.mem);</span><br><span class="line">            bool flag2 = (s.cpu[1] &gt;= v.cpu &amp;&amp; s.mem[1] &gt;= v.mem);</span><br><span class="line">            if(!flag1 &amp;&amp; (!flag2)) continue;</span><br><span class="line">            for(int k = 0; k &lt; MAX_num; k++)&#123;</span><br><span class="line">                if(v_mins[vid][k] == 0) break;</span><br><span class="line">                if(ans_buy[i] == v_mins[vid][k]) &#123;</span><br><span class="line">                    fc = 1;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(flag1 &amp;&amp; fc)&#123;</span><br><span class="line">                near_id = i;</span><br><span class="line">                s_n_id = 1;</span><br><span class="line">                min_dif = -MAX_T;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag2 &amp;&amp; fc)&#123;</span><br><span class="line">                near_id = i;</span><br><span class="line">                s_n_id = 2;</span><br><span class="line">                min_dif = -MAX_T;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(flag1 &amp;&amp; near_id == i &amp;&amp; 2 == s_n_id &amp;&amp; s.cpu[0] &gt; s.cpu[1] &amp;&amp; s.mem[0] &gt; s.mem[1] &amp;&amp; fc)&#123;</span><br><span class="line">                near_id = i;</span><br><span class="line">                s_n_id = 1;</span><br><span class="line">                min_dif = -MAX_T;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if(near_id &gt;= 0) break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q_r = min_dif;</span><br><span class="line">    return near_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_work(const Query &amp;ele, int tim) &#123;</span><br><span class="line">    int bi = v_s[ele.vid].bi;</span><br><span class="line">    int v_cpu = v_s[ele.vid].cpu, v_mem = v_s[ele.vid].mem;</span><br><span class="line">    int q_r_sid = 0;</span><br><span class="line">    double q_r = 0;</span><br><span class="line">    if (bi == 1) &#123;</span><br><span class="line">        int s_n_id = 0;</span><br><span class="line">        int maxx_id = get_near(tim, v_s[ele.vid], s_n_id, ele.vid, q_r, 0);</span><br><span class="line">        if (maxx_id &gt;= 0) &#123;</span><br><span class="line">            Server&amp; buy_s = has_buy_s[maxx_id];</span><br><span class="line">            buy_s.cpu[0] -= v_cpu; buy_s.cpu[1] -= v_cpu;</span><br><span class="line">            buy_s.mem[0] -= v_mem; buy_s.mem[1] -= v_mem;</span><br><span class="line">            //last_buy_s[maxx_id].push_back(q_ed[ele.qid]);</span><br><span class="line">            s_arrange[ele.qid] = Arrange(maxx_id, 3, tim);</span><br><span class="line"></span><br><span class="line">            cur_arrange[ele.qid] = Arrange(maxx_id, 3, tim);</span><br><span class="line">            q_r_sid = maxx_id;</span><br><span class="line">        &#125;</span><br><span class="line">            // 购买新的服务器</span><br><span class="line">        else &#123;</span><br><span class="line">            int cc;</span><br><span class="line">            int sid = get_new_ser(ele.vid, q_r);</span><br><span class="line">            // 上面可能要修改</span><br><span class="line">            has_buy_s.push_back(Server(ser[sid]));</span><br><span class="line">            ans_buy.push_back(sid);</span><br><span class="line">            Total_cost += ser[sid].cost;</span><br><span class="line">            int maxx_id = has_buy_s.size() - 1;</span><br><span class="line"></span><br><span class="line">            //下面为if的重复</span><br><span class="line">            Server&amp; buy_s = has_buy_s[maxx_id];</span><br><span class="line">            buy_s.cpu[0] -= v_cpu; buy_s.cpu[1] -= v_cpu;</span><br><span class="line">            buy_s.mem[0] -= v_mem; buy_s.mem[1] -= v_mem;</span><br><span class="line">            //last_buy_s[maxx_id].push_back(q_ed[ele.qid]);</span><br><span class="line">            s_arrange[ele.qid] = Arrange(maxx_id, 3, tim);</span><br><span class="line"></span><br><span class="line">            cur_arrange[ele.qid] = Arrange(maxx_id, 3, tim);</span><br><span class="line">            q_r_sid = maxx_id;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line">        int s_n_id = 0;</span><br><span class="line">        int maxx_id = get_near(tim, v_s[ele.vid], s_n_id, ele.vid, q_r, 0);</span><br><span class="line">        //debug(maxx_id, s_n_id);</span><br><span class="line">        if (maxx_id &gt;= 0) &#123;</span><br><span class="line">            Server&amp; buy_s = has_buy_s[maxx_id];</span><br><span class="line">            buy_s.cpu[s_n_id - 1] -= v_cpu;</span><br><span class="line">            buy_s.mem[s_n_id - 1] -= v_mem;</span><br><span class="line">            //last_buy_s[maxx_id].push_back(q_ed[ele.qid]);</span><br><span class="line">            s_arrange[ele.qid] = Arrange(maxx_id, s_n_id, tim);</span><br><span class="line"></span><br><span class="line">            cur_arrange[ele.qid] = Arrange(maxx_id, s_n_id, tim);</span><br><span class="line">            q_r_sid = maxx_id;</span><br><span class="line">        &#125;</span><br><span class="line">            // 购买新的服务器</span><br><span class="line">        else &#123;</span><br><span class="line">            int sid = get_new_ser(ele.vid, q_r);</span><br><span class="line">            //debug(sid, s_n_id);</span><br><span class="line">            // 上面可能要修改</span><br><span class="line">            has_buy_s.push_back(Server(ser[sid]));</span><br><span class="line">            ans_buy.push_back(sid);</span><br><span class="line">            Total_cost += ser[sid].cost;</span><br><span class="line">            int maxx_id = has_buy_s.size() - 1;</span><br><span class="line"></span><br><span class="line">            //下面为if的重复</span><br><span class="line">            Server&amp; buy_s = has_buy_s[maxx_id];</span><br><span class="line">            buy_s.cpu[0] -= v_cpu;</span><br><span class="line">            buy_s.mem[0] -= v_mem;</span><br><span class="line">            //last_buy_s[maxx_id].push_back(q_ed[ele.qid]);</span><br><span class="line">            s_arrange[ele.qid] = Arrange(maxx_id, 1, tim);</span><br><span class="line"></span><br><span class="line">            cur_arrange[ele.qid] = Arrange(maxx_id, 1, tim);</span><br><span class="line">            q_r_sid = maxx_id;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q_ratio[ele.qid] = Qratio(ele.qid, ele.vid, q_r_sid, q_r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct QOperate &#123;</span><br><span class="line">    string op; //操作</span><br><span class="line">    string virtual_name; //虚拟机名称</span><br><span class="line">    int id;   //离散化后的id</span><br><span class="line">    QOperate() &#123;&#125;</span><br><span class="line">    QOperate(string op, string name, int id) : op(op), virtual_name(name), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;QOperate&gt; q_operate[MXQ];</span><br><span class="line"></span><br><span class="line">int migration_map[MXQ];</span><br><span class="line">struct Migration_ans&#123;</span><br><span class="line">    int qid, s_id, s_n_id;</span><br><span class="line">    Migration_ans()&#123;&#125;</span><br><span class="line">    Migration_ans(int qid, int s_id, int s_n_id):qid(qid), s_id(s_id), s_n_id(s_n_id)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Migration_ans&gt; migration_ans[MXV];</span><br><span class="line"></span><br><span class="line">int Total_sub;</span><br><span class="line">void work_day(int num, vector&lt;QOperate&gt; const&amp; qop, int tim) &#123;</span><br><span class="line">    vector&lt;Query&gt; add, sub;</span><br><span class="line">    add.clear();</span><br><span class="line">    int num_qid = 0;</span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line"></span><br><span class="line">        int v_id = v_server[qop[i].virtual_name];</span><br><span class="line">        //debug(qop[i].op, qop[i].id, qop[i].virtual_name,v_id);</span><br><span class="line">        string eqa = &quot;add,&quot;;</span><br><span class="line">        num_qid = max(num_qid, qop[i].id);</span><br><span class="line"></span><br><span class="line">        if (eqa.compare(qop[i].op) == 0) &#123;</span><br><span class="line">            add.push_back(Query(qop[i].id, v_id, i));</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //sub.push_back(Query(qop[i].id, v_id, i));</span><br><span class="line">            if (!add.empty()) &#123;</span><br><span class="line">                sort(add.begin(), add.end(), cmp_query);</span><br><span class="line">                for (auto ele : add) &#123;</span><br><span class="line">                    add_work(ele, tim);</span><br><span class="line">                    update_s2v(ele.vid);</span><br><span class="line">                &#125;</span><br><span class="line">                add.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            --T_cnt[tim][v_id];</span><br><span class="line">            sub_work(qop[i].id, v_id);</span><br><span class="line">            Total_sub += 1;</span><br><span class="line">            cur_arrange[qop[i].id] = Arrange(-1, -1, tim);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 防止没有 删除操作</span><br><span class="line">    if (!add.empty()) &#123;</span><br><span class="line">        sort(add.begin(), add.end(), cmp_query);</span><br><span class="line">        for (auto ele : add) &#123;</span><br><span class="line">            add_work(ele, tim);</span><br><span class="line">            update_s2v(ele.vid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    add.clear();</span><br><span class="line">//    if(!sub.empty())&#123;</span><br><span class="line">//        for(auto ele : sub)&#123;</span><br><span class="line">//            --T_cnt[tim][ele.vid];</span><br><span class="line">//            sub_work(ele.qid, ele.vid);</span><br><span class="line">//            Total_sub += 1;</span><br><span class="line">//            cur_arrange[ele.qid] = Arrange(-1, -1, tim);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">//    sub.clear();</span><br><span class="line"></span><br><span class="line">    //迁移</span><br><span class="line">    int siz = has_buy_s.size();</span><br><span class="line">    sort(q_ratio+1,q_ratio+1+num_qid);</span><br><span class="line">    int up = (num_qid-Total_sub) / 200;</span><br><span class="line"></span><br><span class="line">    int cc = 0;</span><br><span class="line">    for(int i = 1; i &lt;= num_qid; i++)&#123;</span><br><span class="line">        if(cc &gt;= up || i == 16*up) break;</span><br><span class="line">        if(cur_arrange[q_ratio[i].qid].s_id &lt; 0) break;</span><br><span class="line"></span><br><span class="line">        VirtualSever &amp;v = v_s[q_ratio[i].v_id];</span><br><span class="line">        int nxt_n_id = 0;</span><br><span class="line">        double nxt_q_r = 0;</span><br><span class="line">        int near_id = get_near(tim, v, nxt_n_id, q_ratio[i].v_id, nxt_q_r, 1);</span><br><span class="line">        if(near_id &lt; 0 || (near_id == cur_arrange[q_ratio[i].qid].s_id &amp;&amp; nxt_n_id == cur_arrange[q_ratio[i].qid].s_n_id)) continue;</span><br><span class="line">        if(near_id &gt; q_ratio[i].s_id) continue;</span><br><span class="line"></span><br><span class="line">        sub_work(q_ratio[i].qid, q_ratio[i].v_id);</span><br><span class="line"></span><br><span class="line">        cc += 1;</span><br><span class="line">        //这里的tim与s_arrange的tim不一样。</span><br><span class="line">        cur_arrange[q_ratio[i].qid] = Arrange(near_id, nxt_n_id, tim);</span><br><span class="line">        //这里为加上去，cpu减少</span><br><span class="line">        sub_work(q_ratio[i].qid, q_ratio[i].v_id, -1);</span><br><span class="line"></span><br><span class="line">        migration_ans[tim].push_back(Migration_ans(migration_map[q_ratio[i].qid], near_id, nxt_n_id ));</span><br><span class="line">        q_ratio[i] = Qratio(q_ratio[i].qid, q_ratio[i].v_id, near_id, nxt_q_r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; siz; i++)&#123;</span><br><span class="line">        const Server&amp; s = has_buy_s[i];</span><br><span class="line">        const Server&amp; ans_ser = ser[ans_buy[i]];</span><br><span class="line">        if(s.cpu[0] &lt; ans_ser.cpu[0] || s.cpu[1] &lt; ans_ser.cpu[1])&#123;</span><br><span class="line">            Total_cost += s.day_cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans_map[MXQ];</span><br><span class="line">int cnt[MXS], sum[MXS];</span><br><span class="line">// 打印转移函数</span><br><span class="line">void migration_print(int tim) &#123;</span><br><span class="line">    int num = migration_ans[tim].size();</span><br><span class="line">    printf(&quot;(migration, %d)\n&quot;, num);</span><br><span class="line">    for(int i = 0; i &lt; num; i++)&#123;</span><br><span class="line">        Migration_ans&amp; ans = migration_ans[tim][i];</span><br><span class="line">        if(ans.s_n_id == 3) printf(&quot;(%d, %d)\n&quot;,ans.qid, ans_map[ans.s_id]);</span><br><span class="line">        else printf(&quot;(%d, %d, %c)\n&quot;, ans.qid, ans_map[ans.s_id], ans.s_n_id==1? &#x27;A&#x27; : &#x27;B&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int preparation_print(int siz)&#123;</span><br><span class="line">    for(int i = 0; i &lt;= N; i++) sum[i] = cnt[i] = 0;</span><br><span class="line">    for(int i = 0; i &lt; siz; i++)&#123;</span><br><span class="line">        ++cnt[ans_buy[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        sum[i] = cnt[i] + sum[i-1];</span><br><span class="line">        cnt[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; siz; i++) &#123;</span><br><span class="line">        int sid = ans_buy[i];</span><br><span class="line">        ++cnt[sid];</span><br><span class="line">        ans_map[i] = sum[sid-1]+cnt[sid]-1;</span><br><span class="line">    &#125;</span><br><span class="line">    int num = 0;</span><br><span class="line">    for(int i = 1; i &lt;= N; i++)&#123;</span><br><span class="line">        if(cnt[i] &gt; 0) ++num;</span><br><span class="line">    &#125;</span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ans_print(int num_q) &#123;</span><br><span class="line">    int last = 0;</span><br><span class="line">    int siz = has_buy_s.size();</span><br><span class="line">    int s_num = preparation_print(siz);</span><br><span class="line">    printf(&quot;(purchase, %d)\n&quot;, s_num);</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        if(cnt[i] &lt;= 0) continue;</span><br><span class="line">        printf(&quot;(%s %d)\n&quot;, ser_name[i], cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= num_q; i++) &#123;</span><br><span class="line">        Arrange&amp; ans = s_arrange[i];</span><br><span class="line">        if (ans.tim != last) &#123;</span><br><span class="line">            if (last &gt; 0)</span><br><span class="line">                printf(&quot;(purchase, 0)\n&quot;);</span><br><span class="line">            migration_print(last);</span><br><span class="line">            last = ans.tim;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans.s_n_id == 3) printf(&quot;(%d)\n&quot;, ans_map[ans.s_id]);</span><br><span class="line">        else printf(&quot;(%d, %c)\n&quot;, ans_map[ans.s_id], ans.s_n_id == 1 ? &#x27;A&#x27; : &#x27;B&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//    freopen(&quot;C:\\Users\\86153\\Desktop\\huawei_competition\\SDK\\training-data\\training-2.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">//    freopen(&quot;C:\\Users\\86153\\Desktop\\huawei_competition\\SDK\\training-data\\training-2-out.txt&quot;,&quot;w&quot;,stdout);</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    char szBuf[24];</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line">    cin.getline(szBuf, 100);</span><br><span class="line">    for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">        int cpu, mem, cost, day_cost;</span><br><span class="line">        scanf(&quot;(%s %d, %d, %d, %d)&quot;, ser_name[i], &amp;cpu, &amp;mem, &amp;cost, &amp;day_cost);</span><br><span class="line">        cin.getline(szBuf, 100);</span><br><span class="line">        ser[i] = Server(cpu, mem, cost, day_cost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanf(&quot;%d\n&quot;, &amp;M);</span><br><span class="line">    for (int i = 1; i &lt;= M; i++) &#123;</span><br><span class="line">        char name[24];</span><br><span class="line">        int cpu, mem, bi;</span><br><span class="line">        scanf(&quot;(%s %d, %d, %d)&quot;, name, &amp;cpu, &amp;mem, &amp;bi);</span><br><span class="line">        cin.getline(szBuf, 100);</span><br><span class="line">        // 双节点要除以2，因为各一半。</span><br><span class="line">        if (bi == 1) &#123;</span><br><span class="line">            cpu /= 2;</span><br><span class="line">            mem /= 2;</span><br><span class="line">        &#125;</span><br><span class="line">        v_s[i] = VirtualSever(cpu, mem, bi);</span><br><span class="line">        v_server[name] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    cin.getline(szBuf, 100);</span><br><span class="line">    int set_id = 0;</span><br><span class="line">    for (int t = 1; t &lt;= T; t++) &#123;</span><br><span class="line">        int num;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        cin.getline(szBuf, 100);</span><br><span class="line">        for (int i = 1; i &lt;= num; i++) &#123;</span><br><span class="line">            QOperate operate = QOperate();</span><br><span class="line">            char op[5];</span><br><span class="line">            char virtual_name[24];</span><br><span class="line">            scanf(&quot;(%s&quot;, op);</span><br><span class="line">            operate.op = op;</span><br><span class="line">            int tras_id = -1;</span><br><span class="line">            string eqa = &quot;add,&quot;;</span><br><span class="line">            if (eqa.compare(operate.op) == 0) &#123;</span><br><span class="line">                int id = 0;</span><br><span class="line">                scanf(&quot;%s %d)&quot;, virtual_name, &amp;id);</span><br><span class="line">                cin.getline(szBuf, 100);</span><br><span class="line">                operate.virtual_name = virtual_name;</span><br><span class="line">                if (!qid.count(id))</span><br><span class="line">                    qid[id] = ++set_id;</span><br><span class="line">                tras_id = qid[id];</span><br><span class="line">                operate.id = tras_id;</span><br><span class="line"></span><br><span class="line">                migration_map[tras_id] = id;</span><br><span class="line">                q_vs[tras_id] = operate.virtual_name;</span><br><span class="line">                cnt_v[v_server[virtual_name]] += 1;</span><br><span class="line">                T_cnt[t][v_server[virtual_name]] += 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                int id = 0;</span><br><span class="line">                scanf(&quot;%d)&quot;, &amp;id);</span><br><span class="line">                cin.getline(szBuf, 100);</span><br><span class="line">                if (!qid.count(id))</span><br><span class="line">                    qid[id] = ++set_id;</span><br><span class="line">                tras_id = qid[id];</span><br><span class="line">                //q_ed[tras_id] = t;</span><br><span class="line">                operate.id = tras_id;</span><br><span class="line">                operate.virtual_name = q_vs[tras_id];</span><br><span class="line"></span><br><span class="line">                T_sub_cnt[t][v_server[operate.virtual_name]] += 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            q_operate[t].push_back(operate);</span><br><span class="line">        &#125;</span><br><span class="line">//        int siz = q_operate[t].size();</span><br><span class="line">//        for(int i = 0; i &lt; siz; i++)&#123;</span><br><span class="line">//            debug(q_operate[t][i].id);</span><br><span class="line">//        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preparation_num(T);</span><br><span class="line"></span><br><span class="line">    for (int t = 1; t &lt;= T; t++) &#123;</span><br><span class="line">        preparation_v2s(T - t);</span><br><span class="line">        work_day(q_operate[t].size(), q_operate[t], t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    debug(Total_cost);</span><br><span class="line">    ans_print(set_id);</span><br><span class="line">//</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/2021%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%AF%94%E8%B5%9B/" data-id="ckq4woa8b0007louug7yfaamk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++ 编译器问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/C++%20%E7%BC%96%E8%AF%91%E5%99%A8%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:37.571Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="GCC-与-g"><a href="#GCC-与-g" class="headerlink" title="GCC 与 g++"></a>GCC 与 g++</h2><p>2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。</p>
<p>误区二:gcc不会定义__cplusplus宏，而g++会实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。</p>
<p>误区三:编译只能用gcc，链接只能用g++严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C++程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/C++%20%E7%BC%96%E8%AF%91%E5%99%A8%E9%97%AE%E9%A2%98/" data-id="ckq4woa870002louuf3am0oxp" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C &amp; C++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/C%20&%20C++/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:28.722Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="NULL-与-nullptr"><a href="#NULL-与-nullptr" class="headerlink" title="NULL 与 nullptr"></a>NULL 与 nullptr</h2><p>在C语言中，NULL通常被定义为：#define NULL ((void *)0)</p>
<p>所以说NULL实际上是一个空指针，如果在C语言中写入以下代码，编译是没有问题的，因为在C语言中把空指针赋给int和char指针的时候，发生了隐式类型转换，把void指针转换成了相应类型的指针。</p>
<h3 id="二、C-程序中的NULL"><a href="#二、C-程序中的NULL" class="headerlink" title="二、C++程序中的NULL"></a>二、C++程序中的NULL</h3><p>但是问题来了，以上代码如果使用C++编译器来编译则是会出错的，因为C++是强类型语言，void*是不能隐式转换成其他类型的指针的，所以实际上编译器提供的头文件做了相应的处理：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/reasonyuanrobot/article/details/100022574">https://blog.csdn.net/reasonyuanrobot/article/details/100022574</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/C%20&%20C++/" data-id="ckq4woa800000louu2fbs3qm1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++ 内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:24.050Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<p><a href="#test" target="_self"> 说明文字 </a></p>
<h3 id="new与operate-new-与-malloc-与-alloc-allocate"><a href="#new与operate-new-与-malloc-与-alloc-allocate" class="headerlink" title="new与operate new 与 malloc 与 alloc::allocate"></a>new与operate new 与 malloc 与 alloc::allocate</h3><p>&emsp;&emsp;指针不能调用构造函数，此过程由编译器完成，可以调用析构函数。</p>
<p>不同的编译器的底层实现可能是不一样的，编译器：VC6，GCC。 VC6可能成功，GCC可能失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc = static_cast&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(1,2)</span><br></pre></td></tr></table></figure>
<p>上述不行，可以改用下面的,直接调用构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new(p)Complex(1,2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* p4 = alloc::allocate(512); </span><br><span class="line">alloc::deallocate(p4,512);   </span><br></pre></td></tr></table></figure>



<p>如果pca是类，调用默认构造函数，那么类的this指针会移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A* tmp = buf;</span><br><span class="line">for(int i = 0; i &lt; size; ++i)</span><br><span class="line">    new(tmp++)A(i);</span><br></pre></td></tr></table></figure>
<p>构造顺序，析构逆序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//分配是有cookie, cookie记录区块大小， 去除的话，区块大小要一致且已知</span><br><span class="line">int *pi = new int[10];</span><br><span class="line">delete pi;   //这里不会报错</span><br><span class="line">//整数(int)没有异议，其他Object可能会有异议</span><br></pre></td></tr></table></figure>
<p>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new允许讲object建构与allocate memory中 </span><br><span class="line">char *buf = new char[sizeof(Complex)*3]</span><br><span class="line">Complex* pc = new(buf)Complex(1, 2);  //buf为已经得到的内存</span><br><span class="line">...</span><br><span class="line">delete [] buf;</span><br></pre></td></tr></table></figure>
<p><span id = "test"><font color = "red"> 跳转位置 </font></span><br>上述编译后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void mem = operator new(sizeof(Complex), buf);</span><br><span class="line">pc = static_cast&lt;Complex*&gt;(mem);</span><br><span class="line">pc-&gt;Complex::Complex(1,2);</span><br></pre></td></tr></table></figure>
<p>一块内存分配有上下两个cookie，上下4字节，共八字节。可以取消重载operator new, 来取消cookie所占的内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般不改::operator new(size_t) 因为影响非常大</span><br><span class="line">foo 一个随意的空间名</span><br><span class="line">一般改Foo::operator new(size_t)</span><br><span class="line">容器一般为</span><br><span class="line">T *p = allocate();</span><br><span class="line">deallocate p;</span><br><span class="line">上述两句一般调用 std::allocator</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//不可被声明于一个namespace内， std？？？</span><br><span class="line">inline void *operator new(size_t size)</span><br><span class="line">inline void *operator new[](size_t size)</span><br><span class="line">inline void operator delete(void *ptr)</span><br><span class="line">inline void operator delete[](void *ptr)</span><br></pre></td></tr></table></figure>

<p>重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = new Foo;</span><br><span class="line">//变成以下三句话</span><br><span class="line">try&#123;</span><br><span class="line">    void* mem = operator new(sizeof(Foo), mem); //此处转class Foo</span><br><span class="line">    p = static_Cast&lt;Foo*&gt;(mem);</span><br><span class="line">    p-&gt;Foo::Foo(1,2); //狗在函数</span><br><span class="line">&#125;</span><br><span class="line">delete p;</span><br><span class="line">//变为以下两句话</span><br><span class="line">p-&gt;~Foo();</span><br><span class="line">operator delete(p);  //此处转class Foo </span><br><span class="line"></span><br><span class="line">class Foo&#123;</span><br><span class="line">    public:</span><br><span class="line">        void* operator new(size_t);</span><br><span class="line">        void operator delete(void*, size_t);</span><br><span class="line">        // 上面两句必须是static因为是在创建对象的过程当中，所以目前算是没有对象的。</span><br><span class="line">&#125;</span><br><span class="line">// operator delete中的size_t重载时是可有可无的</span><br></pre></td></tr></table></figure>
<p>使用双冒号会绕过前面所使用的重载<br>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = ::new Foo(7);</span><br></pre></td></tr></table></figure>

<p>可以重载class member operator new(), 写出多个版本，每一版本要有独特的参数列，其中第一个参数必须是size_t,其余参数以new所制定的placement argument为初值。 </p>
<p>delete 不一定需要一一对应new的重载，一般用来处理异常。不对应重载即放弃处理异常</p>
<p>string 用了 basic_string，多带了一包东西，所以用placement new ，它多个参数,例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rep* p = new(extra)Rep;</span><br></pre></td></tr></table></figure>

<p>嵌入式指针embedded pointer union</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="std-alloc-与-std-poll-alloc"><a href="#std-alloc-与-std-poll-alloc" class="headerlink" title="std::alloc 与 std::_poll_alloc"></a>std::alloc 与 std::_poll_alloc</h3><p>静态成员在类外定义，但是常量好像可以不用。</p>
<p>宏定义可以非常的长，用’\‘表示接着后面一行</p>
<p>G2.9的std:alloc有16种不同的allocator，针对不同大小的类</p>
<p>一些operator new 未能成功分配memory，会抛出一个std::bad_alloc_exception。某些老旧编译器则返回0</p>
<p>VC6 与 BC5 分配的是512个类型的空间（如512个int,512个double)<br>G2.9则不是，分配512个字节，且容器用的也不是defalloc.h里面的alloc. 即不是std::allocator 而是 std::alloc</p>
<p>容器不知道自己是否带cookie, cookie free不带cookie因为是从std::alloc中获得的内存，但是直接从malloc中获得应该是带cookie的，因为std::alloc设计了15个针对不同类的内存的链表(8byte~128byte) 内嵌指针小于4字节就很浪费空间，因为指针至少4字节</p>
<p>向pool中注入32x20x2(2倍数量)+RoudUP(备用),pool一般指的是<br>==”胀备池”为(32x20+RoudUp)==,<br>RoudUp为上一次申请总量右移四位(x&gt;&gt;4)而不包括那个32x20x2。胀备池一般分配尽可能多，但不超过20个。例子：从104(8x13)分配到的胀备池可以用到下次112的分配，只要112*20 &lt;= pool即可。</p>
<h3 id="vc6-amp-vc10的malloc比较"><a href="#vc6-amp-vc10的malloc比较" class="headerlink" title="vc6 &amp; vc10的malloc比较"></a>vc6 &amp; vc10的malloc比较</h3><p>sbh: small block heap， windows自带crt heap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">_ioinit()</span><br><span class="line">    malloc_dbg()</span><br><span class="line">        _nh_malloc_dbg()</span><br><span class="line">            heap_alloc_dbg()</span><br><span class="line">                heap_alloc_base()</span><br><span class="line">                    __sbh_alloc_block()</span><br><span class="line">                     __sbh_alloc_new_region()</span><br><span class="line">                    __sbh_alloc_new_group()</span><br><span class="line"></span><br><span class="line">tpedef struct tagHeader</span><br><span class="line">&#123;</span><br><span class="line">    BITVEC bitvEntryHi;</span><br><span class="line">    BITVEC bitvEntryLo;</span><br><span class="line">    BITVEC bitvCommit;</span><br><span class="line">    void*  pHeapData;</span><br><span class="line">    struct tagRegion* pRegion;</span><br><span class="line">&#125;HEADER, *PHEADER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//_ioinit()的一部分：</span><br><span class="line">    #ifdef _DEBUG</span><br><span class="line">    #define _malloc_crt malloc</span><br><span class="line">    #else /* _DEBUG */</span><br><span class="line">    #defin _THISFILE __FILE__</span><br><span class="line">    #define _malloc_Crt(s) _malloc_dbg</span><br><span class="line">    // 即调用了_malloc_dbg</span><br><span class="line">    void__cdecl_ioinit(void)&#123;</span><br><span class="line">        ...</span><br><span class="line">                typedef struct&#123;</span><br><span class="line">                    long osfhnd;</span><br><span class="line">                    char osfile</span><br><span class="line">                    char pippech;</span><br><span class="line">                &#125;ioinfo;</span><br><span class="line">        // 32 * 8</span><br><span class="line">        if((pio=_malloc_crt(IOINFO_ARRAY_ELTS*sizeof(ioinfo))) == NULL)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">//在debug 下大小会变大</span><br><span class="line">        </span><br><span class="line">        //7*4  + 4 + size_data + 4 两个四当作围栏，前面7个有各种信息</span><br><span class="line">        blockSize = sizeof(_CrtMemBlockHeader) + nSize + nNoMansLandSize;</span><br><span class="line">//调试模型下会多一些结构记录额外的信息，以便于追踪</span><br><span class="line">//windows 下有 vitual allocate</span><br><span class="line"></span><br><span class="line">//__sbh_pHeadferList 包括32个group</span><br><span class="line">//sbh_alloc_new_region() 的部分</span><br><span class="line">    typedef struct tagRegion&#123;</span><br><span class="line">        int intGroupUse;</span><br><span class="line">        char cntRegionSize[64];</span><br><span class="line">        BITVEC bitvGroupHi[32];</span><br><span class="line">        BITVEC bitvGroupLo[32];</span><br><span class="line">        struct tagGroup grpHeadList[32];</span><br><span class="line">    &#125;REGION,*PREGION;</span><br><span class="line">    </span><br><span class="line">    typdef struct tagGroup&#123;</span><br><span class="line">        int cntEntries;</span><br><span class="line">        struct tagListHead listHead[64];</span><br><span class="line">    &#125;GROUP,*PGROUP;</span><br><span class="line">    typdef struct tagList&#123;</span><br><span class="line">        struct tagEntry* pEntryNext;</span><br><span class="line">        struct tagEntry* pEntryPrev;</span><br><span class="line">    &#125;</span><br><span class="line">// crtheap 4096大小    </span><br><span class="line">// 32个group，64条链表， 每个group 8个page， 每个page 有4k。</span><br><span class="line">//每个page，中间主要部分4080， 上下各有4字节的-1即0xffffffff.</span><br><span class="line">//由于4088不是16的倍数，所以浪费了8字节</span><br><span class="line">// 小于1K 会换成另外一个链表链接， 64x16 = 1024. 刚好1K, 所以块大小/16 - 1即为第几对链表。</span><br><span class="line">//所以大于等于1K的都在最后一根链表上</span><br><span class="line">// 为什么要page 4k呢？</span><br></pre></td></tr></table></figure>
<p>cookie用来合并内存，都是一样记录sbh的大小<br>tagroup 里的cntEntries记录分配了多少块内存出去，分配++，回收–。cntEntries == 0表示全回收</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(p)</span><br><span class="line">p </span><br><span class="line">落在哪个Header内？</span><br><span class="line">落在哪个group内？</span><br><span class="line">落在哪个free-list内？</span><br></pre></td></tr></table></figure>
<p>_sbh_pHeaderDefer是个指针，只指向一个全回收group所属的Header。<br>这个group原本应被释放，但暂时保留（延缓释放）。当再有第二个全回收group出现，才释放。<br>在第二个全回收group出现之前，defer指针会被取消（设置为NULL).<br>_sbh_indGroupDefer是个索引，指出Region中哪个group(#0~#31)是defer</p>
<h2 id="VC6，-Heap-State-Reporting-Function"><a href="#VC6，-Heap-State-Reporting-Function" class="headerlink" title="VC6， Heap State Reporting Function"></a>VC6， Heap State Reporting Function</h2><p>GNU C的malloc更复杂<br>叠床效应，上层不能依赖下层，因为操作系统接口不一样，为了更好的迁移性。</p>
<h2 id="loki-allocator"><a href="#loki-allocator" class="headerlink" title="loki::allocator"></a>loki::allocator</h2><p>三个class, 以下为类图的写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SmallObjAllocator&#123;</span><br><span class="line">    poll_:vector&lt;FixedAllocator&gt;</span><br><span class="line">    pLastAlloc:FixedAllocator*</span><br><span class="line">    pLastDeAlloc:FixedAllocator*</span><br><span class="line">&#125;</span><br><span class="line">class FixedAllocator&#123;</span><br><span class="line">    chunks_:vector&lt;Chunk&gt;</span><br><span class="line">    AllocChunk_:Chunk*</span><br><span class="line">    deallocChunk_:Chunk*</span><br><span class="line">&#125;</span><br><span class="line">class Chunk&#123;</span><br><span class="line">    pData_:unsigned char*</span><br><span class="line">    firstAvaliableBlock:unsigned char</span><br><span class="line">    blocksAvaliable_:unsigned char</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deallocate 会使得释放的内存块变为最高优先权，即将内存块接到链表头。</p>
<p>push_back可能对数据进行搬动。</p>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><h3 id="bitmap-index"><a href="#bitmap-index" class="headerlink" title="bitmap index"></a>bitmap index</h3><pre><code>__gnu_cxx::bitmap_allocator

__gnu_cxx::poll_allocator

__gnu_cxx::__mt_alloc

__pool_alloc : private __poolalloc_base

//还有以下alloc
__gnu_cxx::debug_allocator
    包覆于任何allocator之上。
    把客户申请量添加一些信息，存放内存size信息。一旦deallocate()收到一个pointer，
    检查size并以assert()保证吻合。
__gnu_cxx::array_allocator
    内存来自std::array objects.
    用上这个allocator，大小固定容器，就无需再调用::operator new 与 operator delete。
    允许我使用stl abstractions而无需在运行期添乱、增加开销。在program startup情况下也可使用。
    但是startup 的第一个动作就是heap_init()除非在startup之前才比较有用
</code></pre>
<p>一般父类，用户无法触碰和操控的<br>减少使用 operators new 和 operator delete 可以带来速度上的优势，由于已经减少调用malloc了，减少的很有限</p>
<h3 id="array-allocator"><a href="#array-allocator" class="headerlink" title="array_allocator"></a>array_allocator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Array=std::tr1::array&lt;_Tp,1&gt; 为底部C++数组。 数组是静态分配的</span><br><span class="line">template&lt;typename _Tp, typename _Array=std::tr1::array&lt;_Tp,1&gt;&gt;</span><br><span class="line">class array_allocator:public array_allocator_base&lt;_Tp&gt;</span><br></pre></td></tr></table></figure>
<h3 id="debug-allocator"><a href="#debug-allocator" class="headerlink" title="debug_allocator"></a>debug_allocator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    size_type _M_extra;  //记录整个区块的大小，类似于cookie</span><br><span class="line">    _Alloc _M_allocator;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="G4-9-poll-alloc-与-G2-9-的std-alloc-一样，-而不是std-allocator"><a href="#G4-9-poll-alloc-与-G2-9-的std-alloc-一样，-而不是std-allocator" class="headerlink" title="G4.9 _poll_alloc 与 G2.9 的std::alloc 一样， 而不是std::allocator"></a>G4.9 _poll_alloc 与 G2.9 的std::alloc 一样， 而不是std::allocator</h3><h3 id="bitmap-allocator"><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a>bitmap_allocator</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 为什么是free_list</span><br><span class="line">class bitmap_allocator:private free_list&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">第一个super block</span><br><span class="line">// super block size = 4 + 2*4 + 64*8 = 524</span><br><span class="line">// bitmap[0] 与 bitmap[1], unsigned int 32位， 4 byte， 32+32 = 64，以及usecount</span><br><span class="line">// super block 会越来越大</span><br><span class="line">第二个super block</span><br><span class="line">// 4 + 4*4 + 128*8 = 1044, 4*32 = 128,</span><br><span class="line"></span><br><span class="line">// 因为vector一般成倍增长， 下面的vector有三个成员</span><br><span class="line">__mini_vector&#123;</span><br><span class="line">    _M_start;</span><br><span class="line">    _M_finish;  //已经使用过内存的尾巴</span><br><span class="line">    _M_end_of_storage;  //容量的尾巴</span><br><span class="line">&#125;</span><br><span class="line">//如果不全回收，倍增的内存相当惊人，每次全回收下次分配规模减半</span><br><span class="line">//如果不是全回收, 1 super 与 2super 会优先选2 super里面的block 分配</span><br><span class="line">//erase拿掉,失联, 由free list回收 </span><br><span class="line">// 回收大于64,直接delete</span><br><span class="line">// 从free list去一个放进_S_mem_blocks</span><br></pre></td></tr></table></figure>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><pre><code>copy on write
</code></pre>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public :</span><br><span class="line">    int _id; //4字节</span><br><span class="line">    long _Data; //4字节</span><br><span class="line">    string _str; //4字节，指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//以下Foo类里面有虚析构函数</span><br><span class="line">Foo* pArray = new Foo[5];  //怎样的代码表示是否时有虚析构函数的？ 虚函数要多4字节，指针</span><br><span class="line">//不管多少虚函数，都是多一根指针吗？</span><br></pre></td></tr></table></figure>

<p>global scope operator 前面加上:: ,例如 ::new 或 ::delete</p>
<p>重载的delete只有当相应的new 抛出exception蔡慧调用重载的deelte。用来归还未完全建成的object</p>
<p>每次调用new，被编译器替换成了int * ptr = new (__FILE, _LINE) int。<br>其实那个size_t的意思是编译器根据申请对象的类型计算的 就是分配内存的大小，是不需要我们去计算的</p>
<p>size_t 是为了跨平台</p>
<p>函数定义可以不用变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void operator delete(void*,long,char)&#123;</span><br><span class="line">    cout&lt;&lt;&quot;...&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常发生的会一直往外抛异常，直到terminate 与 abort</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckq4woa850001louub1q7e5ej" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/Linux%20/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:19.853Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>COW详述：</p>
<p> 现在有一个父进程P1，这是一个主体，那么它是有灵魂也就身体的。现在在其虚拟地址空间（有相应的数据结构表示）上有：正文段，数据段，堆，栈这四个部分，相应的，内核要为这四个部分分配各自的物理块。即：正文段块，数据段块，堆块，栈块。至于如何分配，这是内核去做的事，在此不详述。</p>
<ol>
<li> 现在P1用fork()函数为进程创建一个子进程P2，</li>
</ol>
<p>内核：</p>
<p>（1）复制P1的正文段，数据段，堆，栈这四个部分，注意是其内容相同。</p>
<p>（2）为这四个部分分配物理块，P2的：正文段－＞PI的正文段的物理块，其实就是==不为P2分配正文段块==，让P2的正文段指向P1的正文段块，数据段－＞P2自己的数据段块（为其分配对应的块），堆－＞P2自己的堆块，栈－＞P2自己的栈块。如下图所示：同左到右大的方向箭头表示复制内容。</p>
<h2 id="linux-bash-shell"><a href="#linux-bash-shell" class="headerlink" title="linux bash shell"></a>linux bash shell</h2><h3 id="通配符与正则表达式"><a href="#通配符与正则表达式" class="headerlink" title="通配符与正则表达式"></a>通配符与正则表达式</h3><p>首先正则表达式分为三类（man grep可以看到，分别是basic RegExs，extended RegExs，perl RegExs）<br>在ubuntu下使用正则表达式的字符串形式的话，一般要对一些符号用转义字符，即’&#39;。<br>以下为特殊字符，必要时候转义<br>.*[]^${}+?|()</p>
<p>为什么ubuntu 上[\d]不行而[0-9]可以？见以下链接<br><a target="_blank" rel="noopener" href="https://www.jb51.net/article/186283.htm">https://www.jb51.net/article/186283.htm</a><br>正则表达式中的’.’在 通配符下是’?’<br>find -name 只支持通配符<br>find -regex 只支持基本正则表达式<br>如果要支持要如下：<br>find ./ -regextype ‘posix-egrep’ -regex</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/Linux%20/" data-id="ckq4woa890005louud293hm4z" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++易错" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/C++%E6%98%93%E9%94%99/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:14.913Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="define-typedef-using-的用法"><a href="#define-typedef-using-的用法" class="headerlink" title="define\ typedef \ using 的用法"></a>define\ typedef \ using 的用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; </span><br><span class="line">using map_int_t = std::map&lt;std::string, T&gt;;</span><br></pre></td></tr></table></figure>
<p>上述语句不能在main函数中，编译不过，C++11标准如下：<br>A template-declaration can appear only as a namespace scope or class scope declaration.上述为模板别名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这种用法是错误的，template不能和typedef混用</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">typedef std::map&lt;std::string, T&gt; map_int_t;</span><br><span class="line"></span><br><span class="line">void foo(void (*func_call)(int, int));</span><br><span class="line">void foo(func_t&lt;int&gt; func_call);  // error: redefinition</span><br></pre></td></tr></table></figure>


<h2 id="copy-constructor与copy-assignment的用法"><a href="#copy-constructor与copy-assignment的用法" class="headerlink" title="copy constructor与copy assignment的用法"></a>copy constructor与copy assignment的用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">class callwitch&#123;</span><br><span class="line">      string name ;</span><br><span class="line">      static int objcount;</span><br><span class="line">      public :</span><br><span class="line">             callwitch(const string&amp; na = &quot;&quot;) : name(na) &#123;</span><br><span class="line">                   objcount ++;</span><br><span class="line">                   print(&quot;callwitch(const string&amp;)&quot;);</span><br><span class="line">             &#125;;</span><br><span class="line">             ~callwitch()&#123;</span><br><span class="line">                   objcount --;</span><br><span class="line">                   print(&quot;~callwitch()&quot;);   </span><br><span class="line">             &#125;</span><br><span class="line">             callwitch(const callwitch&amp; obj):name(obj.name) &#123;</span><br><span class="line">                   name = &quot;copy of &quot; + name;</span><br><span class="line">                   objcount ++;</span><br><span class="line">                   print(&quot;copy constructor&quot;);</span><br><span class="line">             &#125;;</span><br><span class="line">             callwitch&amp; operator=(callwitch&amp; obj)&#123;</span><br><span class="line">                   print(&quot;copy assignment&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             void print(const string&amp; msg = &quot;&quot;)const &#123;</span><br><span class="line">                  if(msg.size() !=0)</span><br><span class="line">                      cout &lt;&lt; msg &lt;&lt; endl ;</span><br><span class="line">               cout &lt;&lt; &#x27;/t&#x27; &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; &quot;objcount = &quot; &lt;&lt; objcount &lt;&lt; endl;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int callwitch::objcount = 0 ;</span><br><span class="line"></span><br><span class="line">callwitch f(callwitch obj)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;returning from f()&quot; &lt;&lt; endl;</span><br><span class="line">   return obj ;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    callwitch c1(&quot;c1&quot;);</span><br><span class="line">    callwitch c2 = c1 ; //copy constructor called。因为此时c2还未被初始化成为对象(即还未构造出来)，无法调用copy assignment函数！</span><br><span class="line">    callwitch c4 ;</span><br><span class="line">    c4 = c1 ;               //copy assignment called</span><br><span class="line">    c2.print(&quot;call f()&quot;); //这一句有三行，name与objcount没变</span><br><span class="line">    callwitch c3 = f(c1);  //也就是说调用了两次拷贝构造函数，而且用了两次， 一次在f()调用拷贝函数后析构了。</span><br><span class="line">    cout &lt;&lt; &quot;call f(),no need return value&quot; &lt;&lt; endl;</span><br><span class="line">    f(c1);</span><br><span class="line">    system(&quot;PAUSE&quot;);</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">//以下是运行结果：</span><br><span class="line">callwitch(int)</span><br><span class="line">        c1: objcount = 1</span><br><span class="line">copy constructor</span><br><span class="line">        copy of c1: objcount = 2</span><br><span class="line">callwitch(int)</span><br><span class="line">        : objcount = 3</span><br><span class="line">copy assignment</span><br><span class="line">        : objcount = 3</span><br><span class="line">call f()</span><br><span class="line">        copy of c1: objcount = 3</span><br><span class="line">copy constructor</span><br><span class="line">        copy of c1: objcount = 4</span><br><span class="line">returning from f()</span><br><span class="line">copy constructor</span><br><span class="line">        copy of copy of c1: objcount = 5</span><br><span class="line">~callwitch()</span><br><span class="line">        copy of c1: objcount = 4</span><br><span class="line">call f(),no need return value</span><br><span class="line">copy constructor</span><br><span class="line">        copy of c1: objcount = 5</span><br><span class="line">returning from f()</span><br><span class="line">copy constructor</span><br><span class="line">        copy of copy of c1: objcount = 6</span><br><span class="line">~callwitch()</span><br><span class="line">        copy of copy of c1: objcount = 5</span><br><span class="line">~callwitch()</span><br><span class="line">        copy of c1: objcount = 4</span><br></pre></td></tr></table></figure>


<h2 id="仿函数为什么需要："><a href="#仿函数为什么需要：" class="headerlink" title="仿函数为什么需要："></a>仿函数为什么需要：</h2><p>RecallFunc() 函数的第三个参数是一个函数指针，用于外部调用，而 IsGreaterThanTen() 函数通常也是外部已经定义好的，它只接受一个参数的函数。如果此时希望将判定的阈值也作为一个变量传入，变为如下函数就不可行了：</p>
<p>（1）阈值作为函数的局部变量。局部变量不能在函数调用中传递，故不可行；</p>
<p>（2）函数传参。这种方法我们已经讨论过了，多个参数不适用于已定义好的 RecallFunc() 函数。</p>
<p>（3）全局变量。我们可以将阈值设置成一个全局变量。这种方法虽然可行，但是不优雅，且非常容易引入 Bug，比如全局变量容易同名，造成命名空间污染。</p>
<p>模板参数传递给一个对象的实例，这是据我所知不允许。您只能将模板参数传递给模板函数或模板对象。</p>
<p>另外，函数对象还有一个函数指针无法匹敌的用法：可以用来封装类成员函数指针！<br>因为函数对象可以携带附加数据，而成员函数指针缺少一个类实体(类实例)指针来调用，因此，可以把类实体指针给函数对象保存起来，就可以用于调用对应类实体成员函数了。</p>
<p>如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。</p>
<h2 id="多态-amp-虚函数-amp-虚函数表"><a href="#多态-amp-虚函数-amp-虚函数表" class="headerlink" title="多态 &amp; 虚函数 &amp; 虚函数表"></a>多态 &amp; 虚函数 &amp; 虚函数表</h2><p>由于子类B和子类C都是继承于基类A，因此他们都会存在一个虚指针用于指向虚函数表。注意，假如子类B和子类C中不存在虚函数，那么这时他们将共用基类A的一张虚函数表，在B和C中用虚指针指向该虚函数表即可。但是，上面的代码设计时子类B和子类C中都有一个虚函数 vfunc1，因此他们就需要各自产生一张虚函数表，并用各自的虚指针指向该表。由于子类B和子类C都对 vfunc1 作了重载，因此他们有三种不同的实现方式，函数地址也不尽相同，在使用的时候需要从各自类的虚函数表中去查找对应的 vfunc1 地址。</p>
<p>对于虚函数 vfunc2，两个子类都没有进行重载操作，所以基类A、子类B和子类C将共用一个 vfunc2，该虚函数的地址会分别保存在三个类的虚函数表中，但他们的地址是相同的。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/98776075">https://zhuanlan.zhihu.com/p/98776075</a></p>
<p>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置，虚函数分有覆盖和无覆盖的情况</p>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法</p>
<p>二、访问non-public的虚函数</p>
<p>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">    private:</span><br><span class="line">        virtual void f() &#123; cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derive : public Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">typedef void*(Fun)(void);</span><br><span class="line">Fun pFun (Fun) *((int*) *(int*)(&amp;d)+0);</span><br></pre></td></tr></table></figure>
<p>以上为访问pivate与protected的方式<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cy568searchx/p/3358715.html">https://www.cnblogs.com/cy568searchx/p/3358715.html</a></p>
<h4 id="以下为多态"><a href="#以下为多态" class="headerlink" title="以下为多态"></a>以下为多态</h4><p>父类和子类各有各的虚表，虚表里面的虚函数指针指向地址可能相同也可能不同，看override情况<br>静态联编也称为编译时多态性，主要通过函数重写实现。动态联编也称为运行时多态性。主要通过继承和虚函数来实现。</p>
<p>编译器对非虚方法使用静态联编，一个父类指针指向一个子类时，静态联编调用的是父类函数。<br>编译器对虚方法使用动态联编，运行时程序才确定对象的类型，此时一个父类指针指向一个子类，调用的是子类的函数。</p>
<p>==[前几天面试遇到一个面试官，对方坚持说是一个实例里面一张虚表，就感觉很奇怪，后来问了一些大佬，回复是看编译器实现，两种都可能。不过多数还是一个指针，共用一张虚表的。]==</p>
<p>overload(重载)(不是多态)，override(覆盖)(运行时多态、虚函数), overwrite(重写)(编译时多态)<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39731083/article/details/81739340">https://blog.csdn.net/weixin_39731083/article/details/81739340</a></p>
<h2 id="常量表达式-amp-函数"><a href="#常量表达式-amp-函数" class="headerlink" title="常量表达式&amp;函数"></a>常量表达式&amp;函数</h2><ul>
<li>函数体只有单一的return返回语句。</li>
<li>函数必须返回值，不能是void函数。</li>
<li>在使用前必须已有定义。</li>
<li>return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是常量表达式。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constexpr int GetConstThree();</span><br><span class="line">int nValue = GetConstThree();                   //没问题，</span><br><span class="line">constexpr int nConstValue = GetConstThree();    //有问题</span><br><span class="line">constexpr int GetConstThree()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.这里我们声明了一个常量表达式函数GetConstThree，在定义函数之前，我们定义了变量nValue和常量表达式nConstValue,在定义nValue时，编译器将GetConstThree()函数转化为一个函数调用，而“函数调用”是指的运行时的过程，这时对于GetConstThree这样的编译时函数已经获得了值，所有所没有问题。而nConstValue要求使用GetConstThree的值，但此值还没有进行编译时计算，所以有问题。</p>
<p>4.这样做的意义非常明显，即如果我们要使得GetConstFour()成为一个编译时的常量，那么其return表达式语句就不能包含运行时才能确定的变量或函数，只有这样，编译器才能在编译时进行常量表达式函数的额值计算。</p>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><p>C语言中的未定义行为（Undefined Behavior）是指C语言标准未做规定的行为。同时，标准也从没要求编译器判断未定义行为，所以这些行为有编译器自行处理，在不同的编译器可能会产生不同的结果，又或者如果程序调用未定义的行为，可能会成功编译，甚至一开始运行时没有错误，只会在另一个系统上，甚至是在另一个日期运行失败。当一个未定义行为的实例发生时，正如语言标准所说，“什么事情都可能发生”，也许什么都没有发生。<br>所以，避免未定义行为，是个明智的决定。</p>
<p>所以，避免未定义行为，是个明智的决定。本文将介绍几种未定义行为，同时欢迎读者纠错和补充。</p>
<p>1.同一运算符中多个操作数的计算顺序（&amp;&amp;、||、?和,运算符除外）<br>例如：x = f()+g(); //错误</p>
<p>f()和g()谁先计算由编译器决定，如果函数f或g改变了另一个函数所使用变量的值，那么x的结果可能依赖于这两个函数的计算顺序。</p>
<p>参考： 《C程序设计语言（第2版）》 P43</p>
<p>2.函数各参数的求值顺序<br>例如： printf(“%d,%d\n”,++n,power(2,n)); //错误</p>
<p>在不同的编译器可能产生不同的结果，这取决于n的自增运算和power调用谁在前谁在后。</p>
<p>需要注意的是，不要和逗号表达式弄混，都好表达式可以参考这篇文章：==c语言中逗号运算符和逗号表达式==</p>
<p>参考： 《C程序设计语言（第2版）》 P43</p>
<p>3.通过指针直接修改 const 常量的值<br>直接通过赋值修改const变量的值，编译器会报错，但通过指针修改则不会，但不同编译器会产生不同的结果，见下面的分析</p>
<p>==根据C++标准，对于修改const变量，属于：未定义行为==</p>
<p>gdb查看其汇编代码（命令：进入gdb，然后输入：disass main）：</p>
<h2 id="常量字符串"><a href="#常量字符串" class="headerlink" title="常量字符串"></a>常量字符串</h2><p>C++ 的string 更类似于java的 stringbuild， const string 像 java 中的string<br>const volatile int i = 10;<br>int <em>pi = (int</em>)(&amp;i);<br>pi是有可能修改成功的，VC6好像不行，VS2010，g++，dev c++可以</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41413441/article/details/80860135">https://blog.csdn.net/weixin_41413441/article/details/80860135</a></p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝构造函数的参数使用引用类型不是为了减少一次内存拷贝， 而是<br>==避免拷贝构造函数无限制的递归下去。==<br>C++可以在堆中建立对象也可以在栈中分配对象。而在java中通常类的对象都分配在堆中，对象的回收由虚拟机的GC垃圾回收机制决定。</p>
<p>C++在用类作为函数的返回值时调用了类的拷贝构造函数，<br>==而且该拷贝构造函数是在堆上分配存储空间==</p>
<p>直接用malloc而不用new的话，是不会调用==成员变量的构造函数的==，也就是说成员变量是基本类型(int,double)之类的就ok</p>
<p>对象指针返回的是栈上的对象，在函数调用结束后已经销毁了，对象指针即为野指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">student* setname(string name)</span><br><span class="line">&#123;</span><br><span class="line">    student* stu=(student*)malloc(sizeof(student));</span><br><span class="line">    new(stu) student;  //stu为指针</span><br><span class="line">    stu-&gt;age=12;</span><br><span class="line">    stu-&gt;name=name;</span><br><span class="line">    return  stu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxiaoqiang001/p/5557704.html">https://www.cnblogs.com/xiaoxiaoqiang001/p/5557704.html</a></p>
<h2 id="Volatile-与-mutable"><a href="#Volatile-与-mutable" class="headerlink" title="Volatile 与 mutable"></a>Volatile 与 mutable</h2><ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li>
</ol>
<p>在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。</p>
<h2 id="默认构造-amp-析构-amp-虚析构"><a href="#默认构造-amp-析构-amp-虚析构" class="headerlink" title="默认构造 &amp; 析构 &amp; 虚析构"></a>默认构造 &amp; 析构 &amp; 虚析构</h2><p>但是记住,编译器合成的默认构造函数仅仅调用类成员对象的默认构造函数,而不对我们类里面的其它变量做任何初始化操作。</p>
<p>类成员对象有默认构造函数,那么编译器就需要显式的来调用这个类成员对象的构造函数。而编译器想显式的调用类成员对象的默认构造函数,就需要自己来合成一些代码来调用。但是记住,==编译器合成的默认构造函数仅仅调用类成员对象的默认构造函数,而不对我们类里面的其它变量做任何初始化操作==。</p>
<p>内嵌的情况与继承的情况都是</p>
<h4 id="带有虚函数的类"><a href="#带有虚函数的类" class="headerlink" title="带有虚函数的类"></a>带有虚函数的类</h4><p>原因是含有虚函数的类对象都含有一个==虚表指针vptr==，编译器需要对vptr设置初值以满足虚函数机制的正确运行，编译器会把这个设置初值的操作放在默认构造函数中。</p>
<h4 id="带有虚基类的类"><a href="#带有虚基类的类" class="headerlink" title="带有虚基类的类"></a>带有虚基类的类</h4><p>虚继承也会在子类对象中被合成一个指向虚基类的指针，因此也要被初始化，所以必须要构造函数，虚基类或者虚继承保证子类对象中只有一份虚基类的对象。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code>相同class的各个objects互为friends(友元)
</code></pre>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><pre><code>数组与指针的定义和声明， 不能申明是指针，定义是数组会出错。
指针的 operator [] 很明显跟数组不一样，详情请看：
https://www.cnblogs.com/fuao2000/p/11006211.html
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/C++%E6%98%93%E9%94%99/" data-id="ckq4woa880004louu0py43x2o" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/python/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:11.016Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h3 id="python-const类"><a href="#python-const类" class="headerlink" title="python const类"></a>python const类</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaxiaoxu/p/9737119.html">https://www.cnblogs.com/xiaxiaoxu/p/9737119.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class _const:</span><br><span class="line"></span><br><span class="line">    class ConstError(TypeError):pass</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line"></span><br><span class="line">        if self.__dict__.has_key(name):</span><br><span class="line"></span><br><span class="line">            raise self.ConstError, &quot;Can&#x27;t rebind const (%s)&quot; %name</span><br><span class="line"></span><br><span class="line">        self.__dict__[name]=value</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.modules[__name__] = _const()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import const</span><br><span class="line"></span><br><span class="line">const.magic = 23</span><br><span class="line"></span><br><span class="line">print const.magic</span><br><span class="line"></span><br><span class="line">const.magic = 33</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Python的函数为什么可以不用传参直接调用函数外定义的变量"><a href="#Python的函数为什么可以不用传参直接调用函数外定义的变量" class="headerlink" title="Python的函数为什么可以不用传参直接调用函数外定义的变量?"></a>Python的函数为什么可以不用传参直接调用函数外定义的变量?</h3><p>一、其中一个原因意味着，调用的是全局变量</p>
<p>二、<strong>main</strong> scope 中的变量也是全局的，跟C++不一样</p>
<p>python多进程默认不能共享全局变量</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><pre><code>bilibili的oid指的就是av号
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/python/" data-id="ckq4woa8a0006louu0cbvamhm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++标准库与泛型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/20/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-20T08:01:04.484Z" itemprop="datePublished">2021-06-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>标准库的头文件不带.h<br>工程中一般不用using namespace std;<br>因为using 的原因scope里的变量，函数等会乱<br>不同编译器的标准库可能会有==细微的差别==<br>enum 在编译器被换成常量，没有地址这点跟constant不一样，跟define 更相似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// &lt;&lt;要隔开因为operator &lt;&lt; 编译器会有歧义，allocator&lt;T&gt;记得和前面的一致</span><br><span class="line">vector&lt; int,allocator&lt;int&gt; &gt;</span><br></pre></td></tr></table></figure>

<h3 id="container"><a href="#container" class="headerlink" title="container"></a>container</h3><p>sequence container 与 associative container<br>set 与 map用红黑树实现</p>
<h4 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h4><p>separate chaining </p>
<p>但是冲突太多导致链表太长的话，查询时间太长。太长重新打散</p>
<p>变量声明与定义：<br>测试的时候，为了方便在哪定义了变量，用到了才定义。头文件也是。<br>项目的时候，可以一起放在最上面。</p>
<p>C++ 的 ::find()<br>正因为 first 和 last 的类型为输入迭代器，因此该函数适用于所有的序列式容器。</p>
<p>C语言有bsearch</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c[i] = string(buf)</span><br></pre></td></tr></table></figure>
<p>只要key不重复，value重复，那么map不会放入失败</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ext/slist&gt;</span><br><span class="line">#include&lt;ext\rray_allocator.h&gt;</span><br><span class="line">#include&lt;ext\t_allocator.h&gt; //multithread 多线程</span><br><span class="line">#include&lt;ext\debug_allocator.h&gt;</span><br><span class="line">#include&lt;ext\pool_allocator.h&gt;</span><br><span class="line">#include&lt;ext\bitmap_allocator.h&gt;</span><br><span class="line">#include&lt;ext\new_allocator.h&gt;</span><br><span class="line">hash_set, hash_mutiset, hash_map, hash_mutimap大概都在ext开头的头文件中</span><br></pre></td></tr></table></figure>
<p>直接使用容器，少用allocator分配器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snprintf(buf, 10, &quot;%d&quot;, i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/20/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%8E%E6%B3%9B%E5%9E%8B/" data-id="ckq4woa880003louu1tk55b4m" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test-my-site" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/17/test-my-site/" class="article-date">
  <time class="dt-published" datetime="2021-06-17T09:49:20.000Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/17/test-my-site/">test_my_site</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/17/test-my-site/" data-id="ckq27905e0001x8uu0d2m9j89" data-title="test_my_site" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/17/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-06-17T09:40:54.180Z" itemprop="datePublished">2021-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/17/hello-world/" data-id="ckq27905a0000x8uu6op597t8" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/20/2021%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E6%AF%94%E8%B5%9B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/20/C++%20%E7%BC%96%E8%AF%91%E5%99%A8%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/20/C%20&%20C++/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/20/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/20/Linux%20/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>